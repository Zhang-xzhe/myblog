(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{612:function(t,e,o){"use strict";o.r(e);var r=o(13),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"简介"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),o("p",[t._v("在前后端分离的应用中，前端拿到的实际上是一个 "),o("code",[t._v("网络地址 (如: http://url.com)")]),t._v("，前端与后端的交互完全是通过 "),o("code",[t._v("HTTP")]),t._v(" 通信实现的。对于前端来说要执行的操作可能非常多，但网络地址只有一个，怎样才能让后端正确执行相应操作呢？我们设想以下几种方案")]),t._v(" "),o("ol",[o("li",[t._v("在 "),o("code",[t._v("HTTP")]),t._v(" 报文中指定操作，后端解析报文后执行")]),t._v(" "),o("li",[t._v("在链接后衔接不同的字符来区分操作 (即路由)")])]),t._v(" "),o("p",[t._v("实际上，现代前后端开发是上面两种方案的结合。我们通过如下例子说明")])])}),[],!1,null,null,null);e.default=s.exports}}]);