(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{592:function(t,n,a){"use strict";a.r(n);var e=a(13),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_1-引用的基本使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用的基本使用"}},[t._v("#")]),t._v(" 1 引用的基本使用")]),t._v(" "),a("p",[t._v("给变量起别名")]),t._v(" "),a("h2",{attrs:{id:"_1-1-语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-语法"}},[t._v("#")]),t._v(" 1.1 语法")]),t._v(" "),a("p",[a("code",[t._v("数据类型 &别名 = 原名")])]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"_1-2-示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-示例"}},[t._v("#")]),t._v(" 1.2 示例")]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('int main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << "a = " << a << endl;\n\tcout << "b = " << b << endl;\n\n\tb = 100;\n\n\tcout << "a = " << a << endl;\n\tcout << "b = " << b << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),a("br"),t._v(" "),a("h1",{attrs:{id:"_2-注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-注意事项"}},[t._v("#")]),t._v(" 2 注意事项")]),t._v(" "),a("ul",[a("li",[t._v("引用必须初始化")]),t._v(" "),a("li",[t._v("引用在初始化后，不可以改变")])]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('int main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << "a = " << a << endl;\n\tcout << "b = " << b << endl;\n\tcout << "c = " << c << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),a("br"),t._v(" "),a("h1",{attrs:{id:"_3-引用做函数参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-引用做函数参数"}},[t._v("#")]),t._v(" 3 引用做函数参数")]),t._v(" "),a("p",[a("code",[t._v("作用")]),t._v("：函数传参时，可以利用引用的技术让形参修饰实参")]),t._v(" "),a("p",[a("code",[t._v("优点")]),t._v("：可以简化指针修改实参")]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << "a:" << a << " b:" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << "a:" << a << " b:" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << "a:" << a << " b:" << b << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n\n')])])]),a("blockquote",[a("p",[t._v("总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单")])]),t._v(" "),a("br"),t._v(" "),a("h1",{attrs:{id:"_4-引用做函数返回值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-引用做函数返回值"}},[t._v("#")]),t._v(" 4 引用做函数返回值")]),t._v(" "),a("p",[a("code",[t._v("作用")]),t._v("：引用是可以作为函数的返回值存在的")]),t._v(" "),a("p",[a("code",[t._v("注意")]),t._v("："),a("strong",[t._v("不要返回局部变量引用")])]),t._v(" "),a("p",[a("code",[t._v("用法")]),t._v("：函数调用作为左值")]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a;\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << "ref = " << ref << endl;\n\tcout << "ref = " << ref << endl;\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << "ref2 = " << ref2 << endl;\n\tcout << "ref2 = " << ref2 << endl;\n\n\ttest02() = 1000;\n\n\tcout << "ref2 = " << ref2 << endl;\n\tcout << "ref2 = " << ref2 << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),a("p",[t._v("​")]),t._v(" "),a("h1",{attrs:{id:"_5-引用的本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-引用的本质"}},[t._v("#")]),t._v(" 5 引用的本质")]),t._v(" "),a("p",[t._v("引用的本质在c++内部实现是一个指针常量")]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << "a:" << a << endl;\n\tcout << "ref:" << ref << endl;\n    \n\tfunc(a);\n\treturn 0;\n}\n')])])]),a("p",[t._v("C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了")]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"_5-1-int-const-p"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-int-const-p"}},[t._v("#")]),t._v(" 5.1 int const* p")]),t._v(" "),a("ol",[a("li",[t._v("等价于 "),a("code",[t._v("const int* p")])]),t._v(" "),a("li",[t._v("可认为p指向的是一个常量")]),t._v(" "),a("li",[t._v("p可重复赋值")]),t._v(" "),a("li",[t._v("不可通过p修改对应地址的值")])]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"_5-2-int-const-p"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-int-const-p"}},[t._v("#")]),t._v(" 5.2 int* const p")]),t._v(" "),a("ol",[a("li",[t._v("不可更改p的值")]),t._v(" "),a("li",[t._v("可以通过p修改p指向的值")])]),t._v(" "),a("br"),t._v(" "),a("h1",{attrs:{id:"_6-常量引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-常量引用"}},[t._v("#")]),t._v(" 6 常量引用")]),t._v(" "),a("p",[t._v("主要用来修饰形参，防止误操作。在函数形参列表中，可以加==const修饰形参，防止形参改变实参")]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);